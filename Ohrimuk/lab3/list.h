//----------------------------------------------------------------------------
#ifndef ListH
#define ListH
#include <iostream>
//----------------------------------------------------------------------------
/*
Шаблон класса: связный список из элементов типа T.
*/
template <class T>
class List {

  private:

  // Включаем определение структуры "узел списка".
  // Узел списка.
  struct Node 
  {
	T Data;					// данные (значение эл-та списка)
    Node *Prev, *Next;  // указатель на предыдущий и следующий узлы

    // Создание отдельного узла.
    Node(const T& data) // конструктор для удобства
      : Data(data),		// копируем данные;
        Prev(NULL),	   // предыдущего и
        Next(NULL)		// последующего узлов нет
    {
    }

  };

  Node *Head,	// первый узел списка
       *Tail;    // последний узел

  // Делаем конструктор копирования и оператор присваивания закрытыми.
  List(const List&) { }
  void operator=(const List&) { }

  public:

  // Включаем определение класса "итератор списка".
  // Итератор списка.
  class Iterator {
    // Класс список объявляется дружественным для доступа к указателю на узел.
    friend List<T>;

    Node* P;	// ук-ль на узел списка, содержащий значение эл-та, на кот-й указывает итератор

    public:
    // Создает итератор, указывающий на эл-т списка, хранящийся в узле по адресу p.
    // По умолчанию ни на что не указывает. Т. к. Node - закрытый тип класса List,
    // то итератор на эл-т может быть создан только функциями-элементами List.
    Iterator(Node* p = NULL)
      : P(p)
    {
    }

    // Операция разыменовывания для константного итератора.
    // Возвращает константую ссылку на значение эл-та.
    const T& operator *() const
    {
    	return P->Data;
    }
    

    // Операция разыменовывания для не константного итератора.
    // Возвращает не константного ссылку на значение эл-та, по которой
    // оно может быть изменено.
    T& operator *()
    {
    	return P->Data;
    }

    // Префиксная операция инкремента. Перемещает итератор к следующему эл-ту списка.
    Iterator operator ++()
    {
    	P = P->Next;		// переходим к следующему эл-ту
   		return *this;		// возвращаем "увеличенный" итератор
    }

    // Постфиксная операция инкремента. Перемещает итератор к следующему эл-ту списка.
    // Аргумент типа int указывает компилятору, что данная функция-операция operator ++
    // является постфиксной.
    Iterator operator ++(int)
    {
    	Iterator t(*this);	// сохраняем "не увеличенное" значение итератора
    	P = P->Next;			// переходим к следующему эл-ту
    	return t;				// возвращаем "не увеличенное" значение итератора
    }

    // Префиксная операция декремента. Перемещает итератор к предыдущему эл-ту списка.
    Iterator operator --()
    {
    	P = P->Prev;     // переходим к предыдущему эл-ту
    	return *this;		// возвращаем "уменьшенный" итератор
    }

    // Постфиксная операция декремента. Перемещает итератор к предыдущему эл-ту списка.
    // Аргумент типа int указывает компилятору, что данная функция-операция operator --
    // является постфиксной.
    Iterator operator --(int)
    {
    	Iterator t(*this);	// сохраняем "не уменьшенное" значение итератора
    	P = P->Prev;        // переходим к предыдущему эл-ту
    	return t;				// возвращаем "не уменьшенное" значение итератора
    }

    // Операция равенства.
    friend bool operator ==(const Iterator& x,const Iterator& y)
    {
    	return y.P == x.P;
    }

    // Операция неравенства.
    friend bool operator !=(const Iterator& x,const Iterator& y)
    {
    	return y.P != x.P;
    }
		
	};

  // Конструктор пустого списка
  List()
    : Head(NULL), Tail(NULL)
  {
  }

  // Деструктор (освобождает память).
  ~List()
  {
  Clear();
  }

  // Возвращает константный итератор на первый элемент (для константного списка).
  const Iterator Begin() const
  {
  		return Iterator(Head);
  }

  // Возвращает итератор на первый элемент (для не константного списка).
  Iterator Begin()
  {
  		return Iterator(Head);
  }

  // Возвращает константный итератор на последний элемент (для константного списка).
  const Iterator Last() const
  {
  		return Iterator(Tail);
  }

  // Возвращает итератор на последний элемент (для не константного списка).
  Iterator Last()
  {
  		return Iterator(Tail);
  }

  // Возвращает константный итератор на "конец" (для константного списка).
  const Iterator End() const
  {
  		return Iterator(NULL);
  }

  // Возвращает итератор на "конец" (для не константного списка).
  Iterator End()
  {
  		return Iterator(NULL);
  }

  // Проверка пустоты списка.
  bool Empty() const
  {
  		return !Head;
  }

  // Вставляет элемент в список перед элементом, на который указывает номер.
  // Если список меньше, то эл-т добавляется в конец списка.
  void Insert(const int nomer, const T& data);

  // Удаляет эл-т, на который указывает итератор номер.
  // Если если список меньше, то эл-т удаляется с конца списка.
  void Delete(const int nomer);
  
  // Удаляет эл-т, на который указывает итератор iter.
  void Delete(const Iterator& iter);

  // Удаляет все эл-ты из списка.
  void Clear();

  // Добавление эл-та в начало списка.
  void PushFront(const T& data) ;

  // Добавление эл-та в конец списка.
  void PushBack(const T& data) ;

  // Удаление первого эл-та.
  void PopFront();

  // Удаление последнего эл-та.
  void PopBack();
  
  // операция вывода списка 
  show()
  {
	Iterator i;
	std::cout << '[';
	// Выводим все элементы кроме последнего, разделяя их запятой.
	for (i = Begin(); i != Last(); i++)
  		std::cout << *i << ", ";
	// Выводим последний элемент (если список не пуст).
	if (i != End()) std::cout << *i;
	std::cout << "]\n";
  }
  
};
//---------------------------------------------------------------------------
// Определение не встраиваемых функций-элементов
//---------------------------------------------------------------------------
template <class T>
void List<T>::Insert(const int nomer, const T& data)
{
	// Если список не пуст, то
	if ((Head) && (nomer!=0))
	{
		int m;
		Iterator i;
		m=0;	
		i=Begin();
		// Ищем узел X, перед которым нужно вставить.
		while( (m<nomer) && (i!= End()) )
		{
			m++;
			i++;
		}
		// Если iter указывает на "конец", то добавляем эл-т в конец списка.
		if (i==End())
		{
			PushBack(data);
		}
		// Иначе вставляем эл-т в "середину" списка.
		else
		{
			Node *t,
			 *n = new Node(data);		// создаем отдельный узел
			t = i.P->Prev;		// в t заносим предшествующий X
    		t->Next = n;        // связываем предшествующий X с новым
    		n->Prev = t;		   // связываем новый с предшествующим X
    		n->Next = i.P;	   // связываем новый с X
    		i.P->Prev = n;      // связываем X с новым
		}
	}
	// Иначе вставляем эл-т в начало
	else
	{
		PushFront(data);
	}
}
//---------------------------------------------------------------------------
template <class T>
void List<T>::Delete(const int nomer)
{
// Если список не пуст, то
	if (Head)
	{
		int m=0;
		Iterator i;
		i=Begin();
		// Ищем узел X, который нужно удалить.
		while( (m<nomer) && (i!= End()) )
		{
			m++;
			i++;
		}
		// Если X первый.
		if (i == Begin())
		{
			PopFront();
		}
		// Иначе, если X последний.
		else if ((i==Last()) || (i==End()))
		{
			void PopBack();
		}
		// Иначе X средний.
		else
		{
			Node *t, *pred, *sled;
			t=i.P;                     //удаляемый элемент
			pred=t->Prev;			//предыдущий
			sled=t->Next;			//следующй
			pred->Next = t->Next;	// связываем предыдущий X со следующим за X,
    		sled->Prev = t->Prev;  // отделяя X от списка
			delete t;				// Удаляем  (уничтожаем и освобождаем память).
		}
	}
}
//---------------------------------------------------------------------------
template <class T>
void List<T>::Delete(const Iterator& iter)
{
Node *t;
Iterator i;
// Ищем узел X, содержащий удаляемый эл-т.
for (i = Begin(); i != End(); i++)
  if (i == iter) break;
// Если не найден, то iter не корректен: ошибка.
//assert(i != End());
t = i.P;
// Если X первый.
if (i == Begin()) {
  // Смещаем первый узел на следующий за ним.
  Head = t->Next;
  // Если он отсутсвует, то список состоит из одного эл-та и
  // нужно сбросить указатель на последний.
  if (!Head) Tail = NULL;
  }
else
  // Иначе, если X последний.
  if (i == Last()) {
    // Смещаем последний узел на ему предшествующий.
    Tail = t->Prev;
    // Если он отсутсвует, то список состоит из одного эл-та и
    // нужно сбросить указатель на первый.
    if (!Tail) Head = NULL;
    }
  else {
    // Иначе X средний.
    t->Prev->Next = t->Next;	// связываем предыдущий X со следующим за X,
    t->Next->Prev = t->Prev;  // отделяя X от списка
    }
// Удаляем X (уничтожаем и освобождаем память).
delete t;
}



//---------------------------------------------------------------------------
template <class T>
void List<T>::Clear()
{
// Если список не пуст.
if (!Empty()) {
  Node *n;
  Iterator i;
  // Удаляем все узлы.
  for (i = Begin(); i != End(); ) {
    n = i.P;	// сохраняем адрес узла
    i++;			// переходим к следующему
    delete n;	// и удаляем текущий
    }
  // Сбрасываем указатели на первый и последний.
  Head = Tail = NULL;
  }
}
//---------------------------------------------------------------------------
//Добавление эл-та в начало списка.
template <class T>
void List<T>::PushFront(const T& data)
{
	Node *n=new Node(data);		// создаем отдельный узел
	// Если список не пуст, то
    if (Head)
      // связываем первый узел с новым;
      Head->Prev = n;
    else
      // иначе новый первый узел является и последним.
      Tail = n;
    // Связываем новый узел с первым,
    n->Next = Head;
    // и делаем его первым.
    Head = n;
}
//---------------------------------------------------------------------------
//Добавление эл-та в конец списка.
template <class T>
void List<T>::PushBack(const T& data)
{
	Node *n=new Node(data);		// создаем отдельный узел
	// Если список не пуст, то
  if (Head)
    // связываем последний узел с новым;
    Tail->Next = n;
  else
    // иначе новый последний узел является и первым.
    Head = n;
  // Связываем новый узел с последним,
  n->Prev = Tail;
  // и делаем новый последним.
  Tail = n;
}
//---------------------------------------------------------------------------
// Удаление первого эл-та.
template <class T>
void List<T>::PopFront()
{
	Node *t=Head;
	// Смещаем первый узел на следующий за ним.
	Head = t->Next;
	// Если он отсутсвует, то список состоит из одного эл-та и
	// нужно сбросить указатель на последний.
	if (!Head) Tail = NULL;
	// Удаляем  (уничтожаем и освобождаем память).
	delete t;
}
//---------------------------------------------------------------------------
// Удаление последнего эл-та.
template <class T>
void List<T>::PopBack()
{
	Node *t=Tail;
	// Смещаем последний узел на ему предшествующий.
    Tail = t->Prev;
    // Если он отсутсвует, то список состоит из одного эл-та и
    // нужно сбросить указатель на первый.
    if (!Tail) Head = NULL;
    // Удаляем  (уничтожаем и освобождаем память).
	delete t;
}
//---------------------------------------------------------------------------
#endif
